import pickle
import pandas as pd
import numpy as np
import warnings
warnings.filterwarnings("ignore", category=FutureWarning, module="sklearn.utils.validation")
#script generated by AI deepseek
import pickle
def log1p_inverse(x):
	return np.exp(x) - 1
def ones_count(x):
	"""计算数字 x 的二进制表示中 1 的个数"""
	return bin(x).count('1')

#use trained model and test / estimate on data
# multicast_features = ['fanout', 'inv_CLOCK', 'cap_load',] + ['toggle']
adderN_features = ['prec_in', 'terms', 'inv_CLOCK', 'cap_load', ] + ['toggle', 'out_toggle']
adderN_features = ['prec_in', 'terms', 'inv_CLOCK', 'cap_load', ] +\
	['toggle_0',	'toggle_1', 'toggle_2', 'toggle_3', 'out_toggle']

def adderN_infer(mult_data, model='generated/PowerModels/adderN.pkl'):
	with open(model,"rb") as f:
		model_loaded = pickle.load(f)
	# mult_features = ['prec1','radix', 'inv_CLOCK', 'cap_load',#, #'toggle_0', 'toggle_1',
	# 'in_0', 'in_1', 'bits_0', 'bits_1']
	mult_data=mult_data.reshape((-1, len(adderN_features)))
	mult_X = np.log1p(mult_data*1e5)
	mult_X = pd.DataFrame(mult_X, columns=adderN_features)
	mult_Y = log1p_inverse(model_loaded.predict(mult_X))/1e10
	return mult_Y

def adderN_infer_sequence(hardware, seq):
	data = np.zeros((len(seq), len(adderN_features)))
	for i in range(len(seq)):
		for l in range(len(hardware)):		
			data[i, l] = hardware[l]
			
	idx = 0	
	prev_a = seq[0]
	for a in seq[1:]:
		toggle = 0
		for i in range(len(a)):
			data[idx, len(hardware)+i] = ones_count(a[i] ^ prev_a[i])
			# toggle += ones_count(a[i] ^ prev_a[i])
		# data[idx, len(hardware)+0] =  toggle
		data[idx, len(hardware) + len(a)+0] = ones_count(np.sum(a) ^ np.sum(prev_a))
		
		prev_a = a
		# data[idx, len(hardware)+0] = ones_count(a)
		idx = idx + 1
	# print(prev_a)
	# print(a)
	a = seq[0]
	toggle = 0
	for i in range(len(a)):
		data[idx, len(hardware)+i] = ones_count(a[i] ^ prev_a[i])
		# toggle += ones_count(a[i] ^ prev_a[i])
	data[idx, len(hardware)+0] =  toggle
	data[idx, len(hardware) +len(a)] = ones_count(np.sum(a) ^ np.sum(prev_a))
	# print(data)
	res = adderN_infer(data)
	return res, np.sum(res)/len(res)
	
if __name__ == "__main__":
	# toggle vs. power
	# seq = [(123,11), (1,22), (41,3), (4,123)]
	seq = [ (0, 0, 0, 0), (127, 127, 127, 127)]#, (12, 231 , 1, 32) ]
	seq = [ (0, 0, 0, 0), (127, 192, 22, 99), (12, 231 , 1, 32), (33, 22, 33, 22), (99,88,77,55) ]
	res = adderN_infer_sequence([8, len(seq[0]), 1, 0.1], seq)
	print(res)
