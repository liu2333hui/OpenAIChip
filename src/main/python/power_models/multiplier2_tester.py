import pickle
import pandas as pd

import numpy as np
import warnings
warnings.filterwarnings("ignore", category=FutureWarning, module="sklearn.utils.validation")
#script generated by AI deepseek
import pickle
def log1p_inverse(x):
	return np.exp(x) - 1
def ones_count(x):
	"""计算数字 x 的二进制表示中 1 的个数"""
	return bin(x).count('1')
	
	
	
mult_features = ['prec1','radix', 'inv_CLOCK', 'cap_load',] + \
		['bits_0', 'bits_1', 'in_0', 'in_1']
		
def get_multiplier2_LUT(prec, hardware = [8,2,1,0.1]):
	
	mult_data = np.zeros(((1<<prec)*(1<<prec), len(mult_features)))
	mult_data[:, 0] = hardware[0] #prec
	mult_data[:, 1] = hardware[1] #radix
	mult_data[:, 2] = hardware[2] #clock
	mult_data[:, 3] = hardware[3]	#cp load
	for i in range((1<<prec)):
		for j in range((1<<prec)):
			mult_data[i*(1<<prec)+j, 4] = ones_count(i)
			mult_data[i*(1<<prec)+j, 5] = ones_count(j)
			mult_data[i*(1<<prec)+j, 6] = i
			mult_data[i*(1<<prec)+j, 7] = j
	mult_power = multiplier2_infer(mult_data)
	return mult_power
	
def multiplier2_infer(mult_data, model='generated/PowerModels/multiplier2.pkl'):
	with open(model,"rb") as f:
		multiplier_model = pickle.load(f)
	# mult_features = ['prec1','radix', 'inv_CLOCK', 'cap_load',#, #'toggle_0', 'toggle_1',
	# 'in_0', 'in_1', 'bits_0', 'bits_1']
	mult_data=mult_data.reshape((-1, len(mult_features)))
	mult_X = np.log1p(mult_data*1e5)
	mult_X = pd.DataFrame(mult_X, columns=mult_features)
	mult_Y = log1p_inverse(multiplier_model.predict(mult_X))/1e10
	return mult_Y

def multiplier2_infer_sequence(hardware, seq):
	data = np.zeros((len(seq), len(mult_features)))
	for i in range(len(seq)):
		for l in range(len(hardware)):		
			data[i, l] = hardware[l]
	idx = 0	
	for a,b in seq:
		data[idx, len(hardware)+0] = ones_count(a)
		data[idx, len(hardware)+1] = ones_count(b)
		data[idx, len(hardware)+2] = a
		data[idx, len(hardware)+3] = b
		idx = idx + 1
	res = multiplier2_infer(data)
	return res, np.sum(res)/len(res)
	
if __name__ == "__main__":
	
	# toggle vs. power
	seq = [(123,11), (1,22), (41,3), (4,123)]
	seq = [(123,11), (1,22), (41,3)]
	seq = [(7,0), (3,0), (2,0), (1,0), (5, 0), (1,0) , (5,0) ,(2,0),(0,0)]#	0,0,0,0,0,0,0,0,0,0

	res = multiplier2_infer_sequence([8,16,1,0.1], seq)
	print(res)
if __name__ == "__main__2":
	# 加载模型
	with open('generated/PowerModels/multiplier2.pkl', 'rb') as f:
		loaded_model = pickle.load(f)
	def log1p_inverse(x):
	    return np.exp(x) - 1
		
	features = ['prec1','radix', 'inv_CLOCK', 'cap_load', #'toggle_0', 'toggle_1',
		'in_0', 'in_1']
		
	for rdx in [2,4,8,16,32]:
		# toggle vs. power
		data = [[8, rdx, 1   ,0.1,    3, 0],
				[8, rdx, 1   ,0.1,    92, 127],
				[8, rdx, 1   ,0.1,    29, 2],
				[8, rdx, 1   ,0.1,    2, 7],
					]
		testing_df = pd.DataFrame(data, columns=features)
		X = np.log1p(testing_df[features]*1e5)
		
		best_m = loaded_model
		y =  log1p_inverse(best_m.predict(X))/1e10
		
		print(y)
		print(np.mean(y))
		
	data = [[8, 2, 1   ,0.1,    0, 0],
			[8, 2, 1   ,0.1,    127, 127],
			]
	testing_df = pd.DataFrame(data, columns=features)
	X = np.log1p(testing_df[features]*1e5)
	
	best_m = loaded_model
	y =  log1p_inverse(best_m.predict(X))/1e10
	
	print(y)
	print(np.mean(y))
	
	data = [[8, 2, 1   ,0.1,    127/2, 127/2],
			]
	testing_df = pd.DataFrame(data, columns=features)
	X = np.log1p(testing_df[features]*1e5)
	
	best_m = loaded_model
	y =  log1p_inverse(best_m.predict(X))/1e10
	
	print(y)
	print(np.mean(y))
	
	