import pickle
import pandas as pd
import numpy as np
import warnings
warnings.filterwarnings("ignore", category=FutureWarning, module="sklearn.utils.validation")
#script generated by AI deepseek
import pickle
def log1p_inverse(x):
	return np.exp(x) - 1
def ones_count(x):
	"""计算数字 x 的二进制表示中 1 的个数"""
	return bin(x).count('1')

#use trained model and test / estimate on data
# multicast_features = ['fanout', 'inv_CLOCK', 'cap_load',] + ['toggle']
SRAM_features = ['entry_bits', 'rows', 'inv_CLOCK', 'cap_load','mode', ] + ['toggle']
SRAM_features=['entry_bits', 'rows', 'inv_CLOCK', 'cap_load',] + ['mode', 'toggle']
READ = 0
WRITE = 1
	
	
def get_SRAMBank_LUT(prec, hardware = [16,256, 1, 0.1]):
	
	data = np.zeros(( 2,prec, len(SRAM_features)))
	data[:,:, 0] = hardware[0] #prec
	data[:,:, 1] = hardware[1] #radix
	data[:,:, 2] = hardware[2] #clock
	data[:,:, 3] = hardware[3]	#cp load
	# data[:, 4] = mode
	for mode in [READ, WRITE]:
		for toggle in range(prec):
			data[mode, toggle, 4] = mode
			data[mode, toggle, 5] = toggle

	data = data.reshape((-1, len(SRAM_features)))
	#print(data)
	power = SRAM_infer(data)
	power = power.reshape((2, -1))
	#print(power, power.shape)
	read_power = power[READ]
	write_power = power[WRITE]
	return read_power, write_power
	
def SRAM_infer(mult_data, model='generated/PowerModels/SRAMBank.pkl'):
	with open(model,"rb") as f:
		model_loaded = pickle.load(f)
	# mult_features = ['prec1','radix', 'inv_CLOCK', 'cap_load',#, #'toggle_0', 'toggle_1',
	# 'in_0', 'in_1', 'bits_0', 'bits_1']
	mult_data=mult_data.reshape((-1, len(SRAM_features)))
	mult_X = np.log1p(mult_data*1e5)
	mult_X = pd.DataFrame(mult_X, columns=SRAM_features)
	mult_Y = log1p_inverse(model_loaded.predict(mult_X))/1e10
	return mult_Y

def SRAM_infer_sequence(hardware, wseq, rseq):
	data = np.zeros((len(wseq)+len(rseq), len(SRAM_features)))
	for i in range(data.shape[0]):
		for l in range(len(hardware)):		
			data[i, l] = hardware[l]
	
	idx = 0	
	prev_a = wseq[0]
	for a in wseq[1:]:
		data[idx, len(hardware) + 0 ] = WRITE
		data[idx, len(hardware) + 1 ] = ones_count(a ^ prev_a)
		prev_a = a
		# data[idx, len(hardware)+0] = ones_count(a)
		idx = idx + 1
	data[idx, len(hardware) + 0 ] = WRITE
	data[idx, len(hardware) + 1 ] = ones_count(prev_a ^ wseq[0])


	if(len(rseq) == 0):
		pass
	else:
		idx = idx + 1
		prev_a = rseq[0]
		for a in rseq[1:]:
			data[idx, len(hardware) + 0 ] = READ
			data[idx, len(hardware) + 1 ] = ones_count(a ^ prev_a)
			prev_a = a
			# data[idx, len(hardware)+0] = ones_count(a)
			idx = idx + 1

		data[idx, len(hardware) + 0 ] = READ
		data[idx, len(hardware) + 1 ] = ones_count(prev_a ^ rseq[0])
		
	print(data)
	res = SRAM_infer(data)
	return res, np.sum(res)/len(res)
	
if __name__ == "__main__":
	r,w = get_SRAMBank_LUT(prec = 8, hardware = [16,256, 1, 0.1])
	print(r)
	print(w)

if __name__ == "__main__2":
	# toggle vs. power
	# seq = [(123,11), (1,22), (41,3), (4,123)]
	seq = [ (0, 0, 0, 0), (127, 127, 127, 127)]#, (12, 231 , 1, 32) ]
	seq = [ (0, 0, 0, 0), (127, 192, 22, 99), (12, 231 , 1, 32), (33, 22, 33, 22), (99,88,77,55) ]
	


	seq = [(WRITE, i) for i in range(10)]+2*[(WRITE,233)] + [ (READ, i) for i in range(10)]+2*[(READ,233)]
	wseq = [0, 233]
	rseq = [0, 233]
	
	wseq = [0, 233]
	rseq = [0, 233]

	wseq = [184,5,133,42,58,230,8,55,31,209]
	rseq = []
	
	#wseq = [i for i in range(10)]+2*[233]
	#rseq = wseq
	res = SRAM_infer_sequence([16,256, 1, 0.1], wseq, rseq)
	print(res)
